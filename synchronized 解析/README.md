### synchronized 实现同步的原理

- Java 对象头。synchronized 是悲观锁，加的锁是存在于 Java 对象头里。以 Hotspot 为例，包含两部分数据；
    1. Mark Word，标记字段。线程 ID 会存在这里，在偏向锁中用到；
    2. Klass Pointer，类似指针。对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
- Monitor，为同步机制。每个 Java 对象都有 Monitor 锁。

　　synchronized 通过 Monitor 来实现线程同步，而 Monitor 是依赖于底层操作系统的 Mutex Lock（互斥锁）来实现的线程同步。<br />
　　这种加锁是重量级的，JDK 1.6 之前只有这种形式，所以效率低。JDK 1.6 后对其优化，有多种加锁形式，所以性能提高了。

### JDK 1.6 的优化
　　为减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。<br />
　　有四种锁状态，分别是无锁、偏向锁、轻量级锁和重量级锁，锁只能升级不能降级。升级过程为，无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁。

### 无锁
　　无锁即使用 CAS 来进行修改、更新操作。

### 偏向锁
　　指一段同步代码一直被一个线程访问，该线程会自动获取锁，偏向锁在 JDK 6 后是默认开启的。<br />
　　**偏向锁通过对比 Java 对象头的 Mark Word 来解决加锁问题，避免执行 CAS 操作。**

- 一个线程在访问同步代码块，获取锁时，会将线程 ID 存到 Java 对象头的 Mark Word 里；
- 同一个线程在获取锁时，先检查 Mark Word 是否存在该线程的 ID，即偏向锁。是则直接获取，不是则用 CAS 更新线程 ID；
- 偏向锁减少了 CAS 操作，只在遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。

### 轻量级锁
　　当锁为偏向锁时，有其他线程访问，偏向锁会升级为轻量级锁。其他线程通过自旋的方式尝试获取锁，不会阻塞，从而提高性能。<br />
　　**轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。**

- 一个线程持有锁，另一个线程等待获取锁时，会使用自旋和 CAS 来获取锁；
- 如果这时有多个线程来获取锁时，轻量级锁会升级为重量级锁。

### 重量级锁
　　除了拥有锁的线程外，其他线程会进入阻塞状态。

### synchronized 缺点
　　无法中断，以及无法超时释放锁，灵活性较差，后来 JUC 的包下的 AQS 解决该问题。

### reference

- [不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)